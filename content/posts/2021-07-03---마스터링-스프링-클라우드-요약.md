---
title: "마스터링 스프링 클라우드 요약"
date: "2021-07-03"
template: "post"
draft: false
slug: "마스터링-스프링-클라우드-요약"
category: "Spring Cloud"
tags:
  - "#Spring Cloud"
  - "#MSA"
description: ""
---

### 01 마이크로서비스 소개

#### 마이크로서비스의 장점

마이크로서비스 : 비즈니스 요구사항을 구현한 하나의 애플리케이션을 느슨하게 연결된 여러 애플리케이션으로 쪼개는 것을 말한다.

마이크로서비스의 장점

1. 대규모의 복잡한 애플리케이션을 지속해서 배포 가능
2. 소스 코드 규모 작음, 이해가 쉬움
3. 영역 분리 명확

#### 스프링 프레임워크로 마이크로서비스 만들기

스프링 클라우드는 서비스 레지스트리, 컨피규레이션 서버, 서킷 브레이커, 클라우드 버스, OAuth 패턴, API 게이트웨이와 같은 마이크로서비스 기반 아키텍처에서 사용되는 모든 검증된 패턴을 구현한다.

#### 클라우드 네이티브 개발

*네이티브 클라우드 애플리케이션이란 클라우드 환경을 위해 잘 설계된 프로그램이다.*

스프링은 클라우드 네이티브 배포의 가속을 위해 설계됐다. 스프링 부터 기반으로 애플리케이션을 개발하면 매우 빠르게 수행할 수 있다.

#### 마이크로서비스 아키텍처 배우기

##### 모놀리식 애플리케이션

+ 레이어 모델 : 클라이언트-API-데이터베이스
+ 전체 시스템을 다시 배포해야 하는 개발 방식

##### API 게이트웨이

API 게이트웨이는 클라이언트의 모든 요청을 다양한 API 종단점으로 **동적**으로 전달한다.  
여기서 동적이라는 말은 서비스 디스커버리의 목록에 기반한다는 것이다.

API 게이트웨이가 특정 서비스 호출을 숨기거나 동적 라우팅 기능만 외에 데이터 추적, 요청 메트릭 수집하고 통계를 낼 수 도 있다.

#### 서비스 디스커버리의 필요성 이해하기

마이크로서비스는 서로 상호작용을 하기 위해서 다른 서비스의 네트워크 주소 정보를 유지해야 한다. 애플리케이션이 재시작된 후에 주소가 동적으로 변경되면 문제가 생긴다. 이런 컨피규레이션을 저장하는 것은 어려운 일이다.

+ 서비스 디스커버리 : 컴퓨터 네트워크상의 디바이스가 제공하는 디바이스와 서비스를 자동으로 감지하는 서비스다. 모든 서비스는 시작 후 다른 서비스가 접근할 수 있는 하나의 중앙 장소에 자신을 등록한다. 등록 키는 대부분 서비스의 네트워크 위치를 사용한다. 아울러 각 마이크로서비스는 등록의 변경 사항도 알아야 한다. 그 정보는 주기적으로 갱신함으로써 얻을 수 있다.

어떤 솔루션은 서비스 디스커버리를 서비 컨피규레이션 기능과 함께 사용한다. 서버 컴피규레이션 기능은 중앙에서 관리할 수 있도록 한다. 일반덕으로 이러한 컨피규레이션은 REST 웹 서비스를 제공하는 서버가 된다. 각 마이크로서비스는 프로세스가 시작할 때 컨피규레이션 서버에 접속해 자신을 위한 입력값을 얻어오려고 시도한다. 이를 위한 방식으로는 버전 제어 시스템(ex. git)에 컨피규레이션을 저장하는 것과 key-value를 저장하는 솔루션(ex. Consul, Zookeeper)을 사용하는 것이 있다.

#### 서비스 간 통신

**부하 분산기**는 대게 API 게이트웨이에 내장돼 있다.  
이 부하 분산기는 디스커버리 서버에 등록된 인스턴스 목록을 가져와야 한다.  
특별한 이유가 없다면 유입되는 트래픽을 모든 실행 중인 인스턴스에 분배하는 **라운드 로빈** 규칙을 적용한다.

##### 마이크로서비스 분류

###### 일대일, 일대다 통신

+ 일대일 통신 : 요청이 하나의 인스턴스에 의해 처리
+ 일대다 통신 : 요청이 다수의 인스턴스에 의해 처리

###### 동기, 비동기 통신

+ 비동기 통신 : 클라이언트가 서비스에 요청을 보낼 때 스레드를 점유하지 않고 나중에 응답

리액티브 마이크로서비스 : 스프링 버전 5부터 지원  
MongoDB, Cassandra와 같은 NoSQL DBMS와 리액티브가 방식으로 통신을 지원하는 라이브러리가 있음  

###### 게시-구독 통신

일대다 통신 타입으로 클라이언트가 메세지를 발행하면 수신 대기 중인 모든 서비스에 의해 메세지가 소비된다. 일반적으로 이 모델은 Apache Kafka, RabbitMQ, ActiveMQ와 같은 메시지 브로커로 구성된다.

#### 장애와 서킷 브레이커

+ 서킷 브레이커 패턴

네트워크 타임아웃 문제의 해결책이다. 서킷 브레이커는 성공 및 실패 요청의 횟수를 센다. 에러의 비율이 가정된 임계치를 넘으면 차단이 발생하고 이후의 시도는 즉시 실패한다. 지정된 기간이 지난 후 API 클라이언트는 요청을 다시 시작하고 성공하면 서킷이 닫혀 정상화된다.

서비스마다 사용할 수 있는 다수의 인스턴스가 있고 그 중 한 인스턴스가 다른 것보다 느리게 동작한다면 부하 분산 처리 시 그 인스턴스는 무시된다.

+ 폴백

네트웨크 분리 장애에 사용되는 메커니즘이다. 요청이 실패했을 때 수행되는 로직이다. 예를 들어 서비스가 캐싱된 데이터나 기본값, 빈 결과 목록을 반환할 수 있다.


