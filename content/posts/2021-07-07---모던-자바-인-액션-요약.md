---
title: "모던 자바 인 액션 요약"
date: "2021-07-07"
template: "post"
draft: false
slug: "Modern-Java-in-Action-summary"
category: "Java"  
tags:
  - "#Java"
description: ""
---

### 스트림

1. 질의어 형식으로 간결한 코딩(SQL 같은 간결함)
2. 처리하는 데이터를 모두 메모리에 저장하지 않을 수도 있도록 설계되었다. 따라서 메모리에 저장할 수 없는 큰 데이터도 문제없이 처리 가능할 수 있다.
3. 컬렉션에서는 할 수 없는 최적화를 적용했다. 예를 들어 스트림의 여러 동작을 그룹화해서 데이터를 여러 번 탐색할 필요 없이 한 번만 탐색할 수 있다. 심지어 컬렉션과 달리 스트림 동작을 병렬화할 수 있다.

### 함수형 프로그래밍

함수를 값으로 취급하는 프로그래밍

# 1. 자바 8,9,10,11 무슨 일이 일어나고 있는가?

## 1.1 역사의 흐름은 무엇인가?

```Java
Collections.sort(inventory, new Comparator<Apple>() {
  public int compare(Apple a1, Apple a2) {
    return a1.getWeight().compareTo(a2.getWeight());
  }
});
```
자바 8을 이용하면 자연어에 더 가깝게 간단한 방식으로 코드를 구현할 수 있다.
```Java
inventory.sort(comparing(Apple::getWeight));
```

멀티코어 CPU 대중화는 자바 8에 영향을 미쳤다. 자바 8이 등장하기 이전에는 대부분의 자바 프로그램은 하나의 코어만 사용했다. 나머지 코어를 활용하려면 스레드를 사용할 수 있지만 관리하기 어렵다는 문제가 있다  
자바는 이러한 병렬 실행 환경을 쉽게 관리하려는 방향으로 진화하려 노력했다.  
**자바 1.0**: 스레드, 락, 메모리 모델 지원  
**자바 5.0**: 스레드 풀, 병렬 실행 컬렉션 지원
**자바 7.0**: 병렬 실행을 위한 포크/조인 프레임워크 지원  
그러나 여전히 개발자 활용하기 쉽지 않았다.  

자바 8은 스트림이라는 새로운 API를 제공한다. 스트림을 이용하면 비용이 매우 비싼 `synchronized` 키워드를 사용하지 않아도 된다.

## 1.2 왜 아직도 자바는 변화하는가?

자바는 지난 1995년 첫 벤타 버전이 공개된 이후로 경쟁 언어를 대신하며 커다란 생태계를 성공적으로 구축했다.

### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치

자바는 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작했다. 스레드와 락을 이용한 동시성도 지원했다. 코드를 JVM 바이트 코드로 컴파일하는 특징 때문에 인터넷 애플릿 프로그램의 주요 언어가 되었다. JDK7에 `invokedynamic`이라는 바이트 코드 덕분에 스칼라, 그루비 같은 언어와 함께 상호동작할 수 있게 되었다. 또한 자바는 다양한 임베디드 컴퓨팅 분야를 장악하고 있다.

#### 자바는 어떻게 대중적인 프로그래밍 언어로 성장했는가?

객체지향은 1990년대에 두 가지 이유로 각광받았다.
1. 캡슐화 -> C에 비해 엔지니어링적인 문제가 적다.
2. 객체지향 -> 일단 만들면 모든 곳에서 실행 가능
3. 하드웨어의 발전 -> 프로그래머의 시간이 중요한 요소로 부각

빅데이터(테라바이트 이상)라는 도전에 직면하면서 자바 8에는 병렬 프로세싱 기능이 강화되었다.

### 1.2.2 스트림 처리

스트림: 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 즉, 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

```bash
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | sort -3
```
파일의 단어를 소문자로 바꾼 다음에 사전순으로 단어를 정렬했을 때 가장 마지막에 위치한 세 단어를 출력하는 프로그램이다. 유닉스에서는 여러 명령(cat, tr, sort, tail)을 병렬로 실행한다.

자바 8에는 java.util.stream 패키지에 스트림 API가 추가되었다. 스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 이제 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 또한 스트림 파이프파인을 이용해서 입력 부분을 여러 CPU 코어에서 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다. 스레드를 사용하지 않으면서 공짜로 병렬성을 얻을 수 있다.

### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

자바 8에 추가된 두 번째는 코드 일부를 API로 전달하는 기능이다. 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. 이러한 기능을 **동작 파라미터화**라고 부른다. 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문이다.

### 1.2.4 병렬성과 공유 가변 데이터

세 번쨰는 '병렬성을 공짜로 얻을 수 있다'라는 말에서 시작된다. 병렬성을 얻는 대신 무엇을 포기해야 할까? 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다. 보통 다른 코드와 동시에, 안전하게 실행하려면 공유된 가변 데이터에 접근하지 않아야 한다. 이러한 함수를 순수함수, 부작용 없는 함수, 상태 없는 함수라 부른다. 기존처럼 synchronized를 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수 있을 것이다.(성능에 악영향을 미친다.)

공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은  **함수형 프로그래밍** 패러다임의 핵심적인 사항이다. 반면 **명령형 프로그래밍** 패러다임에서는 일련의 가변 상태로 프로그램을 정의한다.

### 1.2.5 자바가 진화해야 하는 이유

자바의 진화
1. 제너릭
2. Iterator 대신 for-each

기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가섰다는 것이 자바 8의 가장 큰 변화다. 함수형 프로그래밍에서는 우리가 하려는 작업이 최우선시되며 어떻게 수행하는지는 별개의 문제로 취급된다.

프로그래밍 언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다.

## 1.3 자바 함수

자바 8에서는 함수를 새로운 값의 형식으로 추가했다. 스트림과 연계될 수 있도록 함수를 만들었기 때문이다.

### 함수를 값처럼 취급할때의 장점

프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 이 값을 일급 시민이라고 부른다. 전달할 수 없는 구조체는 이급 시민이다.

+ 일급 시민: int, double
+ 이급 시민: 메서드, 클래스

메서드와 클래스는 그 자체로 값이 될 수 없다. 메서드를 일급 시민으로 만들 수 있다면 유용하게 활용할 수 있다.

### 1.3.1 메서드와 람다를 일급 시민으로

자바 8 설계자들은 메서드를 값으로 취급할 수 있게 설계하도록 결정했다.

1. **메서드 참조**

디렉터리에서 모든 숨겨진 파일을 필터링한다고 가정하자. 우선 주어진 파일이 숨겨져 있는지 여부를 알려주는 메서드를 구현해야 한다. File클래스의 isHidden 메서드를 사용한다.

```Java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
  public boolean accept(File file) {
    return file.isHidden();
  }
});
```

isHidden이라는 메서드만 필요한데, 불필요하게 isHidden을 감산 FileFilter를 인스턴스화해야 할까? 자바 8에선는 다음처럼 코드를 구현할 수 있다.

```Java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

**메서드 참조 ::**를 이용해서 간결하게 만들어줄 수 있다. 자바 8에서는 메서드가 일급시민이다. (기존에 객체 참조를 사용하였다.)

### 람다 : 익명 함수

자바 8에서는 **람다**(익명 함수)를 포함하여 함수도 값으로 취급할 수 있다. Utils::add1이라는 형태로 만들 수 있지만 이용할 수 있는 편리한 클래스나 메서드가 없을 때 람다 문법을 이용하면 더 간결하게 코드를 구현할 수 있다.