---
title: "자바 ORM 표준 JPA 프로그래밍 요약"
date: "2021-06-11"
template: "post"
draft: false
slug: "자바-ORM-표준-JPA-프로그래밍-요약"
category: "JPA"
tags:
  - "#JPA"
description: ""
---

지연로딩 : 실제 객체를 사용하는 시점에 데이터베이스를 조회하는 기능입니다. JPA는 지연로딩 시 코드를 따로 작성하지 않고 **투명**하게 처리합니다.

```Java
// 투명한 엔티티
class Member {
    private Order order;

    public Order getOrder() {
        return order;
    }
}
```
```Java
Member member = jpa.find(Member.class, memberId);

Order order = member.getOrder();
order.getOrderDate(); // Order를 사용하는 시점에 지연로딩
```

### JPA와 비교

**JPA는 같은 트랙잭션일 때 같은 객체가 조회되는 것을 보장합니다.**  
그러므로 다음 코드는 동일성 비교에 성공합니다.

```Java
String memberId = "100";
Member member1 = jpa.find(Member.class, memberId);
Member member2 = jpa.find(Member.class, memberId);

member1 == member2; // 동일성 비교 성공
```

### Hibernate

+ Hibernate : ORM 프레임워크(구현체) 입니다.
+ JPA : ORM 기술에 대한 API 표준 명세입니다. 구현이 없는 인터페이스입니다.

![JPA-01.png](/media/posts/2021-06-11---자바-ORM-표준-JPA-프로그래밍-요약/JPA-01.png)

### 성능

JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공합니다.

```Java
String memberId = "helloId";
Member member1 = jpa.find(memberId);
Member member2 = jpa.find(memberId); // 객체를 재사용
```

같은 트랜잭션 안에서 같은 회원을 두 번 조회하는 코드입니다.  
그러므로 JPA에서는 SELECT SQL을 한 번만 DB에 전달하고 두 번째는 조회한 **회원 객체를 재사용**합니다.

### 애플리케이션 개발

#### 엔티티 매니저 설정

![JPA-02.png](/media/posts/2021-06-11---자바-ORM-표준-JPA-프로그래밍-요약/JPA-02.png)
*엔티티 매니저 생성 과정*

##### 엔티티 매니저 팩토리 생성

*persistence.xml*
```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
  version="2.1">
  <persistence-unit name="jpabook"><!-- 영속성 unit 등록 -->
      <properties>
          <!-- 속성 설정 -->
      </properties>
  </persistence-unit>
</persistence>
```
```Java
EntityManagerFactory emf =
  Persistence.createEntityManagerFactory("jpabook");
```

persistence.xml에서 'jpabook'인 영속성 유닛을 찾아서 엔티티 매니저 팩토리를 생성합니다.  
엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용합니다.

##### 엔티티 매니저 생성

```Java
EntityManager em = emf.createEntityManager();
```

엔티티 매니저를 사용해서 엔티티를 DB에 등록/수정/삭제/조회할 수 있습니다.  
**엔티티 매니저는 DB 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안 된다.**


##### 종료

```Java
em.close(); // 엔티티 매니저 종료
emf.close(); // 엔티티 매니저 팩토리 종료
```

#### 트랜잭션 관리

JPA는 항상 트랜잭션 안에서 데이터를 변경해야 합니다.

```Java
EntityTransaction tx = em.getTransaction(); // 트랜잰션 API
try {
  tx.begin(); // 트랜재션 시작
  logic(em); // 비지니스 로직 실행
  tx.commit(); // 트랜잭션 커밋
} catch(Exception e) {
  tx.rollback(); // 트랜잭션 롤백
}
```

#### 비즈니스 로직

엔티티를 하나 생성한 다음 엔티티 매니저를 통해 DB에 등록, 수정, 삭제, 조회합니다.

##### 등록

```Java
String id = "id1";
Member member = new Member();
member.setId(id);
member.setUsername("지한");
member.setAge(2);

// 등록
em.persist(member);
```

##### 수정

```Java
member.setAge(20);
```
JPA는 어떤 엔티티가 변경되었는지 추적하는 기능을 갖추고 있습니다. 엔티티 값만 변경하면 DB에 값을 변경합니다.

##### 삭제

```Java
em.remove(member);
```

##### 한 건 조회

```Java
Member findMember = em.find(Member.class, id);
```

### 엔티티 매니저 팩토리와 엔티티 매니저

|엔티티 매니저 팩토리|엔티티 매니저|
|---|---|
|스레도 공유 가능, 생성 비용 큼|스레도 공유 불가능, 생성 비용 작음|

### 영속성 컨텍스트

엔티티를 영구 저장하는 환경입니다.

```Java
em.persist(member);
```
`persist()` 메소드는 엔티티 매니저를 사용해서 member 엔티티를 영속성 컨텍스트에 저장합니다.  
영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어집니다.

### 엔티티의 생명주기

+ 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
+ 영속 : 영속성 컨텍스트에 저장된 상태
+ 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
+ 삭제 : 삭제된 상태

### 영속성 컨텍스트

`플러시` : 트랜잭션을 커밋한 순간을 의미합니다.

#### 엔티티 조회

`1차 캐시` : 영속성 컨텍스트 내부의 캐시입니다. Map 자료구조의 key는 @Id로 매핑한 식별자, value는 엔티티 인스턴스입니다.

`em.find()`를 호출하면 먼저 1차 캐시에서 엔티티에서 찾고 1차 캐시없다면 데이터베이스에서 조회 후 1차 캐시에 저장합니다.

#### 엔티티 등록

`쓰기 지연` : 트랜잭션을 커밋하기 직전까지 영속 컨텍스트 내부 저장소에 SQL을 모아둡니다. 그리고 모아둔 쿼리를 DB에 보내는 것을 `쓰기 지연`이라 합니다.

영속성 컨텍스트는 1차 캐시에 엔티티를 저장하면서 동시에 쿼리를 쓰기 지연 저장소에 저장합니다. 그 후 SQL을 데이터베이스에 보내는 `flush`를 하고 트랜잭션을 `commit` 합니다.

### 엔티티 수정

`변경 감지` : 엔티티의 변경사항을 DB에 자동으로 반영하는 기능
`스냅샷` : 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장하는 것

1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 플러시가 호출
2. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 탐색
3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보냄
4. 쓰기 지연 저장소의 SQL을 DB에 보냄
5. 트랜잭션을 커밋

**JPA의 기본 전략은 엔티티의 모든 필드를 업데이트 합니다.**  
그로인해 데이터 전송량이 증가하는 단점이 있지만 다음과 같은 장점이 있습니다.

+ 수정 쿼리가 항상 같으므로 애플리케이션 로딩 시점에 **수정 쿼리를 미리 생성**해두고 재사용할 수 있습니다.
+ DB에 동일한 쿼리를 보내면 DB에서 한 번 **파싱된 쿼리를 재사용**할 수 있습니다.

**필드가 많거나 저장되는 내용이 너무 크다면** 동적 UPDATE SQL을 생성하는 전략을 선택하면 됩니다.(하이버네이트 확장 기능)

```Java
@Entity
// 하이버네이트 확장 기능
@org.hibernate.annotations.DynamicUpdate
@Table(name = "Member")
public class Member {...}
```
참고로 데이터를 저장할 때 데이터가 존재하는(null이 아닌) 필드만으로 INSERT SQL을 동적으로 생성하는 `@DynamicInsert`도 있습니다.  
컬럼이 대략 30개 이상이 되면 정적 수정 쿼리 보다 @DynamicUpdate가 빠르다고 합니다.

### 엔티티 삭제

`em.remove()` : 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록

삭제된 엔티티는 가비지 컬렉션의 대상이 됩니다. 당연히 재사용해서는 안됩니다.

### 플러시

영속성 컨텍스트를 플러시하는 방법은 3가지입니다.

1. `em.flush()`를 직접 호출
2. 트랜잭션 커밋 시 플러시가 자동 호출
3. JPQL 쿼리 실행 시 플러시가 자동 호출

#### 플러시 모드 옵션

1. `FlushModeType.AUTO` : 커밋이나 쿼를 실핼할 때 플러시(default)
2. `FlushModeType.COMMIT` : 커밋할 때만 플러시

```Java
em.setFlushMode(FlushModeType.COMMIT) // 플러시 모드 직접 설정
```

### 준영속

준영속을 만드는 방법은 크게 3가지입니다.
1. em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
2. em.clear() : 영속성 컨텍스트를 완전히 초기화
3. em.close() : 영속성 컨텍스트를 종료

#### detach()

```Java
public void detach(Object entity);
```

영속 상태에서 준영속 상태가 되면 트랜잭션 내에서 실행되었던 `1차 캐시 제거`, `쓰기 지연 저장소의 SQL 제거`됨으로써 DB에 데이터가 저장되지 않습니다.

##### reference

[엔티티 매니저 설정, 생성과정](https://noobnim.tistory.com/54)